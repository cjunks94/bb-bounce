<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>BB-Bounce | Brick Breaker with Global Leaderboard</title>
  <meta name="description" content="Classic arcade Brick Breaker game with global leaderboard. Can you make it to the top 10?">

  <!-- Umami Analytics (using public tracking endpoint) -->
  <script defer src="https://umami-tracking.cjunker.dev/script.js" data-website-id="8966340b-9995-44ac-9b62-5b6caffd6f82"></script>
  <style>
    /* ========================================
       MODERN MOBILE-FIRST RESPONSIVE DESIGN
       ======================================== */

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary-green: #00ff00;
      --secondary-cyan: #00ffff;
      --accent-yellow: #ffff00;
      --bg-dark: #0f0f23;
      --bg-medium: #1a1a3e;
      --border-radius: 10px;
      --spacing-sm: 10px;
      --spacing-md: 20px;
      --spacing-lg: 40px;
    }

    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-medium) 100%);
      color: var(--primary-green);
      min-height: 100vh;
      overflow-x: hidden;
      padding: var(--spacing-sm);
    }

    /* Mobile-first: Stack vertically */
    #container {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--spacing-md);
      max-width: 1400px;
      margin: 0 auto;
      padding: var(--spacing-sm);
    }

    /* Tablet and up: Side-by-side layout */
    @media (min-width: 768px) {
      #container {
        grid-template-columns: 1fr 400px;
        padding: var(--spacing-md);
      }
    }

    /* Desktop: Centered with max width */
    @media (min-width: 1200px) {
      #container {
        grid-template-columns: minmax(600px, 1fr) 400px;
      }
    }

    #gameArea {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    h1 {
      font-size: clamp(1.8rem, 5vw, 2.5rem);
      text-align: center;
      text-shadow: 0 0 10px var(--primary-green), 0 0 20px var(--primary-green);
      margin-bottom: var(--spacing-md);
      animation: glow 2s ease-in-out infinite;
    }

    /* Hide header on mobile to maximize game space */
    @media (max-width: 767px) {
      h1 {
        display: none;
      }
    }

    @keyframes glow {
      0%, 100% { text-shadow: 0 0 10px var(--primary-green), 0 0 20px var(--primary-green); }
      50% { text-shadow: 0 0 20px var(--primary-green), 0 0 40px var(--primary-green); }
    }

    /* Top Bar: Stats and Controls Side-by-Side */
    #topBar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-md);
    }

    @media (max-width: 767px) {
      #topBar {
        gap: var(--spacing-sm);
      }
    }

    /* Responsive UI Stats Panel */
    #ui {
      background: rgba(0,0,0,0.8);
      padding: clamp(10px, 3vw, 15px);
      border: 2px solid var(--primary-green);
      border-radius: var(--border-radius);
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-sm);
      font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      text-align: center;
    }

    #ui > div {
      padding: 5px;
    }

    #ui span {
      color: var(--secondary-cyan);
      font-weight: bold;
      display: block;
      margin-top: 5px;
    }

    /* Game Controls Box */
    #gameControls {
      background: rgba(0,0,0,0.8);
      padding: clamp(10px, 3vw, 15px);
      border: 2px solid var(--primary-green);
      border-radius: var(--border-radius);
      display: flex;
      gap: var(--spacing-sm);
      align-items: center;
      justify-content: center;
    }

    #gameControls .btn {
      margin: 0;
      flex: 1;
      max-width: 150px;
    }

    @media (max-width: 767px) {
      #gameControls .btn {
        font-size: clamp(0.8rem, 2vw, 0.9rem);
        padding: 8px 12px;
        min-width: 80px;
        max-width: none;
      }
    }

    /* Responsive Canvas */
    #canvas {
      background: #000;
      border: 3px solid var(--primary-green);
      border-radius: var(--border-radius);
      display: block;
      width: 100%;
      max-width: 800px;
      height: auto;
      aspect-ratio: 4 / 3;
      margin: 0 auto;
      box-shadow: 0 0 30px rgba(0,255,0,0.5);
      touch-action: none; /* Prevent scrolling on touch */
    }

    /* Mobile: Smaller canvas */
    @media (max-width: 767px) {
      #canvas {
        max-width: 100%;
        aspect-ratio: 3 / 4;
      }
    }

    /* Responsive Leaderboard */
    #leaderboard {
      background: rgba(0,0,0,0.9);
      border: 2px solid var(--primary-green);
      border-radius: var(--border-radius);
      padding: var(--spacing-md);
      max-height: 600px;
      overflow-y: auto;
      box-shadow: 0 0 20px rgba(0,255,0,0.3);
    }

    /* Mobile: Full width, collapsible */
    @media (max-width: 767px) {
      #leaderboard {
        max-height: 400px;
      }
    }

    #leaderboard h2 {
      text-align: center;
      margin-bottom: 15px;
      font-size: clamp(1.4rem, 4vw, 1.8rem);
      color: var(--accent-yellow);
      text-shadow: 0 0 10px var(--accent-yellow);
    }

    #leaderboard ol {
      list-style: none;
      padding: 0;
    }

    #leaderboard li {
      padding: 12px;
      margin-bottom: 8px;
      background: rgba(0,255,0,0.1);
      border: 1px solid #00ff00;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      transition: all 0.3s;
    }

    #leaderboard li:hover {
      background: rgba(0,255,0,0.2);
      transform: translateX(5px);
    }

    #leaderboard li:nth-child(1) { border-color: #ffd700; color: #ffd700; }
    #leaderboard li:nth-child(2) { border-color: #c0c0c0; color: #c0c0c0; }
    #leaderboard li:nth-child(3) { border-color: #cd7f32; color: #cd7f32; }

    .rank { font-weight: bold; margin-right: 10px; }
    .player-name { flex: 1; }
    .player-score { font-weight: bold; color: #00ffff; }

    /* Responsive Controls - Instructions Only */
    #controls {
      text-align: center;
      background: rgba(0,0,0,0.8);
      padding: clamp(8px, 2vw, 12px);
      border: 2px solid var(--primary-green);
      border-radius: var(--border-radius);
    }

    #controls p {
      margin: 5px 0;
      font-size: clamp(0.75rem, 2vw, 0.85rem);
      color: var(--secondary-cyan);
    }

    /* Hide control instructions on mobile to save space */
    @media (max-width: 767px) {
      #controls {
        display: none;
      }
    }

    /* Responsive Buttons */
    .btn {
      background: var(--primary-green);
      color: var(--bg-dark);
      border: none;
      padding: clamp(10px, 2vw, 12px) clamp(16px, 4vw, 24px);
      font-size: clamp(0.9rem, 2.5vw, 1rem);
      font-weight: bold;
      cursor: pointer;
      border-radius: 5px;
      margin: 5px;
      transition: all 0.3s;
      font-family: 'Courier New', monospace;
      min-width: 100px;
    }

    .btn:hover {
      background: var(--secondary-cyan);
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(0,255,255,0.8);
    }

    .btn:active {
      transform: scale(0.95);
    }

    /* Mobile button adjustments for game over modal */
    @media (max-width: 767px) {
      #gameOverScreen .btn {
        width: 100%;
        max-width: 280px;
        margin: 8px auto;
        display: block;
      }
    }

    /* Responsive Game Over Modal */
    #gameOverScreen {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 3px solid #ff0000;
      border-radius: 15px;
      padding: clamp(20px, 5vw, 40px);
      text-align: center;
      z-index: 1000;
      max-width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }

    #gameOverScreen.show {
      display: block;
      animation: fadeIn 0.5s;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -60%); }
      to { opacity: 1; transform: translate(-50%, -50%); }
    }

    #gameOverScreen h2 {
      font-size: clamp(2rem, 6vw, 3rem);
      color: #ff0000;
      text-shadow: 0 0 20px #ff0000;
      margin-bottom: var(--spacing-md);
    }

    #gameOverScreen p {
      font-size: clamp(1rem, 3vw, 1.5rem);
      margin: 12px 0;
      line-height: 1.4;
    }

    #nameInput {
      background: #000;
      color: var(--primary-green);
      border: 2px solid var(--primary-green);
      padding: 12px 16px;
      font-size: clamp(1.1rem, 3vw, 1.2rem);
      font-family: 'Courier New', monospace;
      border-radius: 5px;
      margin: var(--spacing-md) auto;
      width: 90%;
      max-width: 280px;
      display: block;
      text-align: center;
    }

    #nameInput::placeholder {
      font-size: 1rem;
    }

    #loading {
      display: none;
      color: #00ffff;
      margin: 15px 0;
      animation: blink 1s infinite;
    }

    #submitMessage {
      min-height: 40px;
      margin: 15px 0 !important;
      font-weight: bold;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    /* Settings Modal */
    #settingsModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 3px solid var(--primary-green);
      border-radius: 15px;
      padding: clamp(20px, 5vw, 40px);
      z-index: 1000;
      max-width: 90%;
      width: 500px;
      max-height: 90vh;
      overflow-y: auto;
    }

    #settingsModal.show {
      display: block;
      animation: fadeIn 0.3s;
    }

    #settingsModal h2 {
      font-size: clamp(1.5rem, 4vw, 2rem);
      color: var(--accent-yellow);
      text-shadow: 0 0 10px var(--accent-yellow);
      margin-bottom: 20px;
      text-align: center;
    }

    .setting-group {
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(0,255,0,0.3);
    }

    .setting-group:last-child {
      border-bottom: none;
    }

    .setting-label {
      display: block;
      font-size: 1.1rem;
      color: var(--secondary-cyan);
      margin-bottom: 10px;
      font-weight: bold;
    }

    .speed-options {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .speed-option {
      background: rgba(0,255,0,0.1);
      border: 2px solid var(--primary-green);
      color: var(--primary-green);
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      transition: all 0.3s;
      min-width: 80px;
      text-align: center;
    }

    .speed-option:hover {
      background: rgba(0,255,0,0.2);
      transform: scale(1.05);
    }

    .speed-option.active {
      background: var(--primary-green);
      color: var(--bg-dark);
      box-shadow: 0 0 20px rgba(0,255,0,0.8);
    }

    .setting-description {
      color: #999;
      font-size: 0.9rem;
      margin-top: 8px;
      line-height: 1.4;
    }

    #settingsModal .btn {
      width: 100%;
      max-width: 200px;
      margin: 20px auto 0;
      display: block;
    }

    /* Additional Mobile Optimizations */
    @media (max-width: 767px) {
      body {
        padding: 5px;
      }

      #gameArea {
        gap: 15px;
      }

      #leaderboard {
        order: 2; /* Show leaderboard below game on mobile */
      }

      #gameOverScreen {
        padding: 25px 15px;
        width: 95%;
      }

      #gameOverScreen h2 {
        margin-bottom: 15px;
      }

      #gameOverScreen p {
        margin: 10px 0;
      }
    }

    /* Landscape mobile */
    @media (max-width: 767px) and (orientation: landscape) {
      #container {
        grid-template-columns: 1fr 300px;
      }

      #canvas {
        aspect-ratio: 16 / 9;
      }
    }

    /* Scrollbar styling */
    #leaderboard::-webkit-scrollbar {
      width: 8px;
    }

    #leaderboard::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.5);
      border-radius: 10px;
    }

    #leaderboard::-webkit-scrollbar-thumb {
      background: #00ff00;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="gameArea">
      <h1>üéÆ BB-BOUNCE</h1>

      <!-- Top Bar: Stats + Controls -->
      <div id="topBar">
        <div id="ui">
          <div>Score: <span id="score">0</span></div>
          <div>Lives: <span id="lives">3</span></div>
          <div>Level: <span id="level">1</span></div>
          <div>Speed: <span id="speedDisplay">1x</span></div>
        </div>
        <div id="gameControls">
          <button class="btn" id="restartBtn">New Game</button>
          <button class="btn" id="pauseBtn">Pause</button>
          <button class="btn" id="settingsBtn">‚öôÔ∏è Settings</button>
        </div>
      </div>

      <canvas id="canvas" width="800" height="600"></canvas>

      <div id="controls">
        <p><strong>Controls:</strong> Arrow Keys / Mouse / Touch to move paddle</p>
        <p>Spacebar or Tap to launch ball | ESC to pause</p>
      </div>
    </div>

    <div id="leaderboard">
      <h2>üèÜ TOP 10 GLOBAL</h2>
      <ol id="scoresList">
        <li style="text-align:center; color:#666;">Loading...</li>
      </ol>
      <div style="text-align:center; margin-top:20px;">
        <button class="btn" id="refreshBtn">Refresh</button>
      </div>
    </div>
  </div>

  <!-- Game Over Modal -->
  <div id="gameOverScreen">
    <h2>GAME OVER</h2>
    <p>Final Score: <span id="finalScore" style="color:#00ffff;">0</span></p>
    <p>Level Reached: <span id="finalLevel" style="color:#ffff00;">1</span></p>
    <p id="rankMessage" style="color:#00ff00; margin:20px 0;"></p>

    <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" value="">
    <br>
    <button class="btn" id="submitBtn">Submit Score</button>
    <button class="btn" id="playAgainBtn">Play Again</button>
    <p id="loading">Submitting...</p>
    <p id="submitMessage" style="margin-top:10px;"></p>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal">
    <h2>‚öôÔ∏è GAME SETTINGS</h2>

    <div class="setting-group">
      <label class="setting-label">Ball Speed Multiplier</label>
      <div class="speed-options">
        <button class="speed-option active" data-speed="1">1x Normal</button>
        <button class="speed-option" data-speed="2">2x Fast</button>
        <button class="speed-option" data-speed="3">3x Extreme</button>
      </div>
      <p class="setting-description">
        Controls how fast the ball moves. Higher speeds = harder gameplay but more challenge!
      </p>
    </div>

    <button class="btn" id="closeSettingsBtn">Close</button>
  </div>

  <script>
    // ============================================
    // BB-BOUNCE - BRICK BREAKER GAME
    // Vanilla JavaScript + Canvas API
    // Author: Christopher Junker
    // ============================================

    // API Configuration
    const API_URL = window.location.origin + '/api';
    const SCORE_SECRET = 'b3481ca0fc3799ed1e124e795eb34420d58281677a4ffa60dfd306b4c7f3fefd';

    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Responsive canvas sizing
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      // Determine aspect ratio based on viewport
      const isMobile = window.innerWidth < 768;
      const isLandscape = window.innerWidth > window.innerHeight;

      let targetWidth, targetHeight;

      if (isMobile && !isLandscape) {
        // Mobile portrait: 3:4 ratio (taller canvas)
        targetWidth = 600;
        targetHeight = 800;
      } else if (isMobile && isLandscape) {
        // Mobile landscape: 16:9 ratio
        targetWidth = 800;
        targetHeight = 450;
      } else {
        // Desktop: 4:3 ratio (original)
        targetWidth = 800;
        targetHeight = 600;
      }

      canvas.width = targetWidth;
      canvas.height = targetHeight;
    }

    // Game constants (will scale with canvas size)
    const PADDLE_WIDTH = 100;
    const PADDLE_HEIGHT = 15;
    const PADDLE_SPEED = 8;
    const BALL_RADIUS = 10;
    const BALL_SPEED_INITIAL = 4;
    const BRICK_ROWS = 5;
    const BRICK_COLS = 10;
    const BRICK_WIDTH = 75;
    const BRICK_HEIGHT = 20;
    const BRICK_PADDING = 5;
    const BRICK_OFFSET_TOP = 60;
    const BRICK_OFFSET_LEFT = 30;

    // Game state
    let score = 0;
    let lives = 3;
    let level = 1;
    let highScore = parseInt(localStorage.getItem('bbBounceHigh') || '0');
    let speedMultiplier = parseFloat(localStorage.getItem('bbBounceSpeedMultiplier') || '1');
    let gameRunning = false;
    let gamePaused = false;
    let ballLaunched = false;

    // Paddle
    let paddleX = (canvas.width - PADDLE_WIDTH) / 2;
    let rightPressed = false;
    let leftPressed = false;
    let mouseX = paddleX;
    let touchX = paddleX;

    // Ball
    let ballX = canvas.width / 2;
    let ballY = canvas.height - 30;
    let ballSpeedX = 0;
    let ballSpeedY = 0;
    let ballSpeed = BALL_SPEED_INITIAL;

    // Bricks
    let bricks = [];

    // ============================================
    // DIFFICULTY SCALING SYSTEM
    // ============================================

    /**
     * Calculate number of brick rows based on current level
     * Levels 1-5: Add 1 row per level (5, 6, 7, 8, 9 rows)
     * Level 6+: Cap at 10 rows maximum
     * @param {number} currentLevel - The current game level
     * @returns {number} Number of brick rows (5-10)
     */
    function calculateBrickRows(currentLevel) {
      const baseRows = 5;
      const maxRows = 10;
      return Math.min(baseRows + currentLevel - 1, maxRows);
    }

    /**
     * Calculate block hit requirements based on level
     * Levels 1-6: All 1-hit blocks
     * Levels 7+: Progressive introduction of multi-hit blocks
     * @param {number} currentLevel - The current game level
     * @param {number} rowIndex - Row index (0-based)
     * @returns {number} Required hits to destroy (1-4)
     */
    function calculateBlockHitRequirement(currentLevel, rowIndex) {
      // Phase 1: Levels 1-6 - Standard 1-hit blocks only
      if (currentLevel <= 6) {
        return 1;
      }

      // Phase 2: Levels 7-9 - Introduce 2-hit blocks (50%)
      if (currentLevel >= 7 && currentLevel <= 9) {
        // Top 50% of rows become 2-hit blocks
        const totalRows = calculateBrickRows(currentLevel);
        const twoHitThreshold = Math.floor(totalRows / 2);
        return rowIndex < twoHitThreshold ? 2 : 1;
      }

      // Phase 3: Levels 10-12 - Add 3-hit blocks
      if (currentLevel >= 10 && currentLevel <= 12) {
        const totalRows = calculateBrickRows(currentLevel);
        const threeHitThreshold = Math.floor(totalRows * 0.25); // Top 25%
        const twoHitThreshold = Math.floor(totalRows * 0.65); // Next 40%

        if (rowIndex < threeHitThreshold) return 3;
        if (rowIndex < twoHitThreshold) return 2;
        return 1;
      }

      // Phase 4: Levels 13+ - Progressive hardening
      if (currentLevel >= 13) {
        const totalRows = calculateBrickRows(currentLevel);
        const threeHitThreshold = Math.floor(totalRows * 0.5); // Top 50%
        const twoHitThreshold = Math.floor(totalRows * 0.8); // Next 30%

        if (rowIndex < threeHitThreshold) return 3;
        if (rowIndex < twoHitThreshold) return 2;
        return 1;
      }

      return 1;
    }

    /**
     * Get color for brick based on hit requirement and current state
     * @param {number} maxHits - Maximum hits required
     * @param {number} currentHits - Current hit count
     * @param {number} rowIndex - Row index for base color
     * @returns {string} Hex color code
     */
    function getBrickColor(maxHits, currentHits, rowIndex) {
      const baseColors = ['#ff0000', '#ff7700', '#ffff00', '#00ff00', '#0077ff'];
      const baseColor = baseColors[rowIndex % baseColors.length];

      // For 1-hit blocks, use standard bright colors
      if (maxHits === 1) {
        return baseColor;
      }

      // For multi-hit blocks, darken based on remaining hits
      const hitRatio = currentHits / maxHits;

      // Parse hex color
      const r = parseInt(baseColor.substr(1, 2), 16);
      const g = parseInt(baseColor.substr(3, 2), 16);
      const b = parseInt(baseColor.substr(5, 2), 16);

      // Darken color based on damage (more hits = darker)
      const darkenFactor = 0.4 + (hitRatio * 0.6); // 40% to 100% brightness
      const newR = Math.floor(r * darkenFactor);
      const newG = Math.floor(g * darkenFactor);
      const newB = Math.floor(b * darkenFactor);

      return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
    }

    /**
     * Calculate score for destroying a block
     * @param {number} maxHits - Maximum hits required for this block
     * @returns {number} Points awarded
     */
    function calculateBlockScore(maxHits) {
      const baseScore = 10;
      switch(maxHits) {
        case 1: return baseScore;        // 10 points
        case 2: return baseScore * 2.5;  // 25 points
        case 3: return baseScore * 5;    // 50 points
        case 4: return baseScore * 10;   // 100 points
        default: return baseScore;
      }
    }

    // ============================================
    // GAME INITIALIZATION
    // ============================================

    function init() {
      resizeCanvas(); // Set canvas dimensions based on viewport
      score = 0;
      lives = 3;
      level = 1;
      gameRunning = true;

      // Start paused on mobile to prevent accidental starts
      const isMobile = window.innerWidth < 768;
      gamePaused = isMobile;
      if (gamePaused) {
        document.getElementById('pauseBtn').textContent = 'Start';
      }

      ballLaunched = false;
      ballSpeed = BALL_SPEED_INITIAL;
      updateUI();
      initBricks();
      resetBall();
      gameLoop();
      loadLeaderboard();
    }

    function initBricks() {
      bricks = [];

      // Calculate dynamic number of rows based on current level
      const currentRows = calculateBrickRows(level);

      // Calculate responsive brick dimensions
      const margin = 20; // Side margins
      const availableWidth = canvas.width - (margin * 2);
      const totalPadding = BRICK_PADDING * (BRICK_COLS - 1);
      const brickWidth = (availableWidth - totalPadding) / BRICK_COLS;

      // Use consistent brick height (scaled proportionally for responsive width)
      // This keeps bricks at fixed height across all levels, letting rows naturally fill more space
      const brickHeight = BRICK_HEIGHT * (brickWidth / BRICK_WIDTH);

      for (let c = 0; c < BRICK_COLS; c++) {
        bricks[c] = [];
        for (let r = 0; r < currentRows; r++) {
          // Calculate hit requirements for this block
          const maxHits = calculateBlockHitRequirement(level, r);

          bricks[c][r] = {
            x: margin + c * (brickWidth + BRICK_PADDING),
            y: BRICK_OFFSET_TOP + r * (brickHeight + BRICK_PADDING),
            width: brickWidth,
            height: brickHeight,
            status: 1,                    // 0 = destroyed, 1 = active
            maxHits: maxHits,             // NEW: Total hits required to destroy
            currentHits: 0,               // NEW: Number of times hit
            color: getBrickColor(maxHits, 0, r)
          };
        }
      }
    }

    function resetBall() {
      ballX = paddleX + PADDLE_WIDTH / 2;
      ballY = canvas.height - 50;
      ballSpeedX = 0;
      ballSpeedY = 0;
      ballLaunched = false;
    }

    function launchBall() {
      if (!ballLaunched && gameRunning && !gamePaused) {
        const angle = (Math.random() - 0.5) * Math.PI / 3; // -30¬∞ to +30¬∞
        const effectiveSpeed = ballSpeed * speedMultiplier;
        ballSpeedX = effectiveSpeed * Math.sin(angle);
        ballSpeedY = -effectiveSpeed * Math.cos(angle);
        ballLaunched = true;
      }
    }

    // ============================================
    // GAME LOOP
    // ============================================

    function gameLoop() {
      if (!gameRunning) return;

      if (!gamePaused) {
        update();
      }

      // Always draw, even when paused (shows scene with overlay)
      draw();

      requestAnimationFrame(gameLoop);
    }

    function update() {
      // Move paddle
      if (rightPressed && paddleX < canvas.width - PADDLE_WIDTH) {
        paddleX += PADDLE_SPEED;
      }
      if (leftPressed && paddleX > 0) {
        paddleX -= PADDLE_SPEED;
      }

      // Mouse/touch control
      if (mouseX !== null) {
        paddleX = Math.max(0, Math.min(canvas.width - PADDLE_WIDTH, mouseX - PADDLE_WIDTH / 2));
      }

      // Ball follows paddle if not launched
      if (!ballLaunched) {
        ballX = paddleX + PADDLE_WIDTH / 2;
        ballY = canvas.height - 50;
        return;
      }

      // Move ball
      ballX += ballSpeedX;
      ballY += ballSpeedY;

      // Wall collision (left/right)
      if (ballX + ballSpeedX > canvas.width - BALL_RADIUS || ballX + ballSpeedX < BALL_RADIUS) {
        ballSpeedX = -ballSpeedX;
      }

      // Wall collision (top)
      if (ballY + ballSpeedY < BALL_RADIUS) {
        ballSpeedY = -ballSpeedY;
      }

      // Paddle collision
      if (ballY + BALL_RADIUS > canvas.height - PADDLE_HEIGHT - 20 && ballY < canvas.height - 20) {
        if (ballX > paddleX && ballX < paddleX + PADDLE_WIDTH) {
          // Add spin based on where ball hits paddle
          const hitPos = (ballX - paddleX) / PADDLE_WIDTH; // 0 to 1
          const angle = (hitPos - 0.5) * Math.PI / 2; // -45¬∞ to +45¬∞
          const effectiveSpeed = ballSpeed * speedMultiplier;
          ballSpeedX = effectiveSpeed * Math.sin(angle);
          ballSpeedY = -Math.abs(effectiveSpeed * Math.cos(angle)); // Always up
        }
      }

      // Bottom collision (lose life)
      if (ballY + ballSpeedY > canvas.height - BALL_RADIUS) {
        loseLife();
      }

      // Brick collision
      checkBrickCollision();
    }

    function checkBrickCollision() {
      for (let c = 0; c < BRICK_COLS; c++) {
        // Use actual array length for dynamic rows
        if (!bricks[c]) continue;

        for (let r = 0; r < bricks[c].length; r++) {
          const brick = bricks[c][r];
          if (!brick || brick.status === 0) continue;

          // Check collision
          if (
            ballX > brick.x &&
            ballX < brick.x + brick.width &&
            ballY > brick.y &&
            ballY < brick.y + brick.height
          ) {
            // Bounce ball
            ballSpeedY = -ballSpeedY;

            // Increment hit count
            brick.currentHits++;

            // Check if brick should be destroyed
            if (brick.currentHits >= brick.maxHits) {
              // Destroy brick
              brick.status = 0;

              // Award full score based on block difficulty
              score += calculateBlockScore(brick.maxHits);
            } else {
              // Partial hit - award partial points and update color
              score += 5; // Partial credit for hitting but not destroying

              // Update brick color to show damage
              brick.color = getBrickColor(brick.maxHits, brick.currentHits, r);
            }

            updateUI();

            // Check level complete
            if (checkAllBricksCleared()) {
              levelComplete();
            }

            // Only process one brick collision per frame
            return;
          }
        }
      }
    }

    function checkAllBricksCleared() {
      return bricks.every(col => col.every(brick => brick.status === 0));
    }

    function levelComplete() {
      score += level * 100; // Bonus
      level++;
      ballSpeed += 0.5; // Increase difficulty
      initBricks();
      resetBall();
      updateUI();
      showMessage(`Level ${level}!`, '#ffff00');
    }

    function loseLife() {
      lives--;
      updateUI();
      if (lives <= 0) {
        gameOver();
      } else {
        resetBall();
        showMessage(`${lives} lives left`, '#ff7700');
      }
    }

    function gameOver() {
      gameRunning = false;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('bbBounceHigh', highScore);
      }
      showGameOverScreen();
    }

    // ============================================
    // RENDERING
    // ============================================

    function draw() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw bricks
      bricks.forEach(col => {
        col.forEach(brick => {
          if (brick.status === 1) {
            // Draw brick fill
            ctx.fillStyle = brick.color;
            ctx.fillRect(brick.x, brick.y, brick.width, brick.height);

            // Draw border (enhanced for multi-hit blocks)
            if (brick.maxHits > 1) {
              // Multi-hit blocks have thicker, glowing borders
              ctx.strokeStyle = brick.currentHits > 0 ? '#ff00ff' : '#00ffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

              // Add inner border for damaged blocks
              if (brick.currentHits > 0) {
                ctx.strokeStyle = 'rgba(255,0,255,0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(brick.x + 2, brick.y + 2, brick.width - 4, brick.height - 4);
              }
            } else {
              // Standard blocks have thin white borders
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 1;
              ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
            }
          }
        });
      });

      // Draw paddle
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(paddleX, canvas.height - 30, PADDLE_WIDTH, PADDLE_HEIGHT);

      // Draw ball
      ctx.beginPath();
      ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = '#00ffff';
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.closePath();

      // Draw pause overlay with button
      if (gamePaused) {
        // Semi-transparent overlay (lighter so game is visible)
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const isMobile = window.innerWidth < 768;

        // Draw centered START button
        const buttonWidth = Math.min(canvas.width * 0.6, 300);
        const buttonHeight = 80;
        const buttonX = (canvas.width - buttonWidth) / 2;
        const buttonY = (canvas.height - buttonHeight) / 2;

        // Button shadow
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(buttonX + 4, buttonY + 4, buttonWidth, buttonHeight);

        // Button background
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

        // Button border
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 4;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

        // Button text
        const fontSize = Math.min(buttonWidth / 6, 36);
        ctx.fillStyle = '#000';
        ctx.font = `bold ${fontSize}px Courier New`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const message = isMobile ? 'TAP TO START' : 'CLICK TO START';
        ctx.fillText(message, canvas.width / 2, canvas.height / 2);

        // Instruction text above button
        ctx.font = `${fontSize * 0.5}px Courier New`;
        ctx.fillStyle = '#ffff00';
        ctx.fillText('Game Ready', canvas.width / 2, buttonY - 30);
      }
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('lives').textContent = lives;
      document.getElementById('level').textContent = level;
      document.getElementById('speedDisplay').textContent = speedMultiplier + 'x';
    }

    function showMessage(text, color) {
      // Simple flash message on canvas (could be improved)
      console.log(text);
    }

    // ============================================
    // INPUT HANDLING
    // ============================================

    // Keyboard
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
      if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
      if (e.key === ' ' || e.key === 'Spacebar') launchBall();
      if (e.key === 'Escape') togglePause();
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
      if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
    });

    // Mouse
    document.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      // Scale mouse position to canvas coordinates
      const scaleX = canvas.width / rect.width;
      mouseX = (e.clientX - rect.left) * scaleX;
    });

    canvas.addEventListener('click', (e) => {
      // If paused, clicking unpauses (acts like Start button)
      if (gamePaused) {
        togglePause();
      } else {
        // If not paused, launch ball
        launchBall();
      }
    });

    // Touch
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      // Scale touch position to canvas coordinates
      const scaleX = canvas.width / rect.width;
      mouseX = (touch.clientX - rect.left) * scaleX;
    }, { passive: false });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      // Snap paddle to touch position
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      // Scale touch position to canvas coordinates
      const scaleX = canvas.width / rect.width;
      mouseX = (touch.clientX - rect.left) * scaleX;

      // If paused, unpause (acts like Start button)
      if (gamePaused) {
        togglePause();
      } else {
        // If not paused, launch ball
        launchBall();
      }
    }, { passive: false });

    // Buttons
    document.getElementById('restartBtn').addEventListener('click', init);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('refreshBtn').addEventListener('click', loadLeaderboard);
    document.getElementById('settingsBtn').addEventListener('click', openSettings);
    document.getElementById('closeSettingsBtn').addEventListener('click', closeSettings);

    function togglePause() {
      if (!gameRunning) return;
      gamePaused = !gamePaused;

      const pauseBtn = document.getElementById('pauseBtn');
      if (gamePaused) {
        pauseBtn.textContent = 'Resume';
      } else {
        pauseBtn.textContent = 'Pause';
      }
    }

    function openSettings() {
      // Pause game if running
      if (gameRunning && !gamePaused) {
        togglePause();
      }

      // Update active button based on current speed
      document.querySelectorAll('.speed-option').forEach(btn => {
        const btnSpeed = parseFloat(btn.dataset.speed);
        if (btnSpeed === speedMultiplier) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });

      document.getElementById('settingsModal').classList.add('show');
    }

    function closeSettings() {
      document.getElementById('settingsModal').classList.remove('show');
    }

    // Speed option handlers
    document.querySelectorAll('.speed-option').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const newSpeed = parseFloat(e.target.dataset.speed);
        setSpeedMultiplier(newSpeed);

        // Update active state
        document.querySelectorAll('.speed-option').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
      });
    });

    function setSpeedMultiplier(multiplier) {
      speedMultiplier = multiplier;
      localStorage.setItem('bbBounceSpeedMultiplier', multiplier);
      updateUI();

      // If ball is launched, update its speed immediately
      if (ballLaunched) {
        const currentSpeed = Math.sqrt(ballSpeedX ** 2 + ballSpeedY ** 2);
        const targetSpeed = ballSpeed * speedMultiplier;
        const ratio = targetSpeed / currentSpeed;
        ballSpeedX *= ratio;
        ballSpeedY *= ratio;
      }
    }

    // ============================================
    // LEADERBOARD API
    // ============================================

    async function loadLeaderboard() {
      try {
        const res = await fetch(`${API_URL}/scores`);
        const data = await res.json();
        displayLeaderboard(data.scores || []);
      } catch (error) {
        console.error('Failed to load leaderboard:', error);
        document.getElementById('scoresList').innerHTML = '<li style="color:#ff0000;">Offline</li>';
      }
    }

    function displayLeaderboard(scores) {
      const list = document.getElementById('scoresList');
      if (scores.length === 0) {
        list.innerHTML = '<li style="text-align:center;color:#666;">No scores yet!</li>';
        return;
      }

      list.innerHTML = scores.map((s, i) => {
        const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;
        return `
          <li>
            <span class="rank">${medal}</span>
            <span class="player-name">${s.name}</span>
            <span class="player-score">${s.score.toLocaleString()}</span>
          </li>
        `;
      }).join('');
    }

    async function submitScore() {
      const name = document.getElementById('nameInput').value.trim() || 'Anonymous';
      const loading = document.getElementById('loading');
      const submitBtn = document.getElementById('submitBtn');
      const message = document.getElementById('submitMessage');

      loading.style.display = 'block';
      submitBtn.disabled = true;
      message.textContent = '';

      try {
        const res = await fetch(`${API_URL}/submit`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name,
            score,
            level,
            secret: SCORE_SECRET
          })
        });

        const data = await res.json();

        if (res.ok) {
          message.style.color = '#00ff00';
          message.textContent = `üéâ Score submitted! You're rank #${data.rank}`;
          localStorage.setItem('bbBounceName', name);
          setTimeout(loadLeaderboard, 1000);
        } else {
          message.style.color = '#ff0000';
          message.textContent = data.error || 'Submission failed';
        }
      } catch (error) {
        message.style.color = '#ff7700';
        message.textContent = 'Offline. Score saved locally.';
        // Queue for later (could implement retry logic)
      } finally {
        loading.style.display = 'none';
        submitBtn.disabled = false;
      }
    }

    function showGameOverScreen() {
      document.getElementById('finalScore').textContent = score.toLocaleString();
      document.getElementById('finalLevel').textContent = level;
      document.getElementById('nameInput').value = localStorage.getItem('bbBounceName') || '';

      const msg = score >= 1000 ? `Amazing! ${score} points!` : score >= 500 ? 'Great job!' : 'Better luck next time!';
      document.getElementById('rankMessage').textContent = msg;

      document.getElementById('gameOverScreen').classList.add('show');
    }

    document.getElementById('submitBtn').addEventListener('click', submitScore);
    document.getElementById('playAgainBtn').addEventListener('click', () => {
      document.getElementById('gameOverScreen').classList.remove('show');
      init();
    });

    document.getElementById('nameInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') submitScore();
    });

    // ============================================
    // START GAME
    // ============================================

    init();
  </script>
</body>
</html>
