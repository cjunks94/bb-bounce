<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>BB-Bounce | Brick Breaker with Global Leaderboard</title>
  <meta name="description" content="Classic arcade Brick Breaker game with global leaderboard. Can you make it to the top 10?">

  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#00ff00">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="BB-Bounce">

  <!-- Umami Analytics (using public tracking endpoint) -->
  <script defer src="https://umami-tracking.cjunker.dev/script.js" data-website-id="8966340b-9995-44ac-9b62-5b6caffd6f82"></script>
  <style>
    /* ========================================
       MODERN MOBILE-FIRST RESPONSIVE DESIGN
       ======================================== */

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary-green: #00ff00;
      --secondary-cyan: #00ffff;
      --accent-yellow: #ffff00;
      --bg-dark: #0f0f23;
      --bg-medium: #1a1a3e;
      --border-radius: 10px;
      --spacing-sm: 10px;
      --spacing-md: 20px;
      --spacing-lg: 40px;
    }

    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-medium) 100%);
      color: var(--primary-green);
      min-height: 100vh;
      overflow-x: hidden;
      padding: var(--spacing-sm);
    }

    /* Mobile-first: Stack vertically */
    #container {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--spacing-md);
      max-width: 1400px;
      margin: 0 auto;
      padding: var(--spacing-sm);
    }

    /* Tablet and up: Side-by-side layout */
    @media (min-width: 768px) {
      #container {
        grid-template-columns: 1fr 400px;
        padding: var(--spacing-md);
      }
    }

    /* Desktop: Centered with max width */
    @media (min-width: 1200px) {
      #container {
        grid-template-columns: minmax(600px, 1fr) 400px;
      }
    }

    #gameArea {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    h1 {
      font-size: clamp(1.8rem, 5vw, 2.5rem);
      text-align: center;
      text-shadow: 0 0 10px var(--primary-green), 0 0 20px var(--primary-green);
      margin-bottom: var(--spacing-md);
      animation: glow 2s ease-in-out infinite;
    }

    /* Hide header on mobile to maximize game space */
    @media (max-width: 767px) {
      h1 {
        display: none;
      }
    }

    @keyframes glow {
      0%, 100% { text-shadow: 0 0 10px var(--primary-green), 0 0 20px var(--primary-green); }
      50% { text-shadow: 0 0 20px var(--primary-green), 0 0 40px var(--primary-green); }
    }

    /* Top Bar: Stats and Controls Side-by-Side */
    #topBar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-md);
    }

    @media (max-width: 767px) {
      #topBar {
        gap: var(--spacing-sm);
      }
    }

    /* Responsive UI Stats Panel */
    #ui {
      background: rgba(0,0,0,0.8);
      padding: clamp(10px, 3vw, 15px);
      border: 2px solid var(--primary-green);
      border-radius: var(--border-radius);
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-sm);
      font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      text-align: center;
    }

    #ui > div {
      padding: 5px;
    }

    #ui span {
      color: var(--secondary-cyan);
      font-weight: bold;
      display: block;
      margin-top: 5px;
    }

    /* Game Controls Box - Uniform Grid Layout */
    #gameControls {
      background: rgba(0,0,0,0.8);
      padding: clamp(12px, 3vw, 16px);
      border: 2px solid var(--primary-green);
      border-radius: var(--border-radius);
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: clamp(8px, 2vw, 12px);
      align-items: stretch;
    }

    #gameControls .btn {
      margin: 0;
      width: 100%;
      padding: clamp(10px, 2.5vw, 14px);
      font-size: clamp(0.85rem, 2vw, 1rem);
      min-width: 0; /* Allow shrinking below content size */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Mobile: Smaller buttons, tighter spacing */
    @media (max-width: 767px) {
      #gameControls {
        padding: clamp(8px, 2vw, 12px);
        gap: clamp(6px, 1.5vw, 8px);
      }

      #gameControls .btn {
        font-size: clamp(0.75rem, 2vw, 0.85rem);
        padding: clamp(8px, 2vw, 10px) clamp(6px, 1.5vw, 8px);
      }
    }

    /* Very small screens: Stack in 2x2 grid */
    @media (max-width: 400px) {
      #gameControls {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      #gameControls .btn {
        padding: 10px 8px;
        font-size: 0.8rem;
      }
    }

    /* Responsive Canvas */
    #canvas {
      background: #000;
      border: 3px solid var(--primary-green);
      border-radius: var(--border-radius);
      display: block;
      width: 100%;
      max-width: 800px;
      height: auto;
      aspect-ratio: 4 / 3;
      margin: 0 auto;
      box-shadow: 0 0 30px rgba(0,255,0,0.5);
      touch-action: none; /* Prevent scrolling on touch */
    }

    /* Mobile: Smaller canvas */
    @media (max-width: 767px) {
      #canvas {
        max-width: 100%;
        aspect-ratio: 3 / 4;
      }
    }

    /* Responsive Leaderboard */
    #leaderboard {
      background: rgba(0,0,0,0.9);
      border: 2px solid var(--primary-green);
      border-radius: var(--border-radius);
      padding: var(--spacing-md);
      max-height: 600px;
      overflow-y: auto;
      box-shadow: 0 0 20px rgba(0,255,0,0.3);
    }

    /* Mobile: Full width, collapsible */
    @media (max-width: 767px) {
      #leaderboard {
        max-height: 400px;
      }
    }

    #leaderboard h2 {
      text-align: center;
      margin-bottom: 15px;
      font-size: clamp(1.4rem, 4vw, 1.8rem);
      color: var(--accent-yellow);
      text-shadow: 0 0 10px var(--accent-yellow);
    }

    #leaderboard ol {
      list-style: none;
      padding: 0;
    }

    #leaderboard li {
      padding: 12px;
      margin-bottom: 8px;
      background: rgba(0,255,0,0.1);
      border: 1px solid #00ff00;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      transition: all 0.3s;
    }

    #leaderboard li:hover {
      background: rgba(0,255,0,0.2);
      transform: translateX(5px);
    }

    #leaderboard li:nth-child(1) { border-color: #ffd700; color: #ffd700; }
    #leaderboard li:nth-child(2) { border-color: #c0c0c0; color: #c0c0c0; }
    #leaderboard li:nth-child(3) { border-color: #cd7f32; color: #cd7f32; }

    .rank { font-weight: bold; margin-right: 10px; }
    .player-name { flex: 1; }
    .player-score { font-weight: bold; color: #00ffff; }

    /* Responsive Controls - Instructions Only */
    #controls {
      text-align: center;
      background: rgba(0,0,0,0.8);
      padding: clamp(8px, 2vw, 12px);
      border: 2px solid var(--primary-green);
      border-radius: var(--border-radius);
    }

    #controls p {
      margin: 5px 0;
      font-size: clamp(0.75rem, 2vw, 0.85rem);
      color: var(--secondary-cyan);
    }

    /* Hide control instructions on mobile to save space */
    @media (max-width: 767px) {
      #controls {
        display: none;
      }
    }

    /* Responsive Buttons - Uniform & Cute */
    .btn {
      background: var(--primary-green);
      color: var(--bg-dark);
      border: 2px solid transparent;
      padding: clamp(10px, 2vw, 12px) clamp(16px, 4vw, 24px);
      font-size: clamp(0.9rem, 2.5vw, 1rem);
      font-weight: bold;
      cursor: pointer;
      border-radius: 8px;
      margin: 5px;
      transition: all 0.2s ease-out;
      font-family: 'Courier New', monospace;
      min-width: 100px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn:hover {
      background: var(--secondary-cyan);
      border-color: var(--primary-green);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,255,255,0.6);
    }

    .btn:active {
      transform: translateY(0px);
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }

    /* Focus state for accessibility */
    .btn:focus {
      outline: 2px solid var(--accent-yellow);
      outline-offset: 2px;
    }

    /* Mobile button adjustments for game over modal */
    @media (max-width: 767px) {
      #gameOverScreen .btn {
        width: 100%;
        max-width: 280px;
        margin: 8px auto;
        display: block;
      }
    }

    /* Responsive Game Over Modal */
    #gameOverScreen {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 3px solid #ff0000;
      border-radius: 15px;
      padding: clamp(20px, 5vw, 40px);
      text-align: center;
      z-index: 1000;
      max-width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }

    #gameOverScreen.show {
      display: block;
      animation: fadeIn 0.5s;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -60%); }
      to { opacity: 1; transform: translate(-50%, -50%); }
    }

    #gameOverScreen h2 {
      font-size: clamp(2rem, 6vw, 3rem);
      color: #ff0000;
      text-shadow: 0 0 20px #ff0000;
      margin-bottom: var(--spacing-md);
    }

    #gameOverScreen p {
      font-size: clamp(1rem, 3vw, 1.5rem);
      margin: 12px 0;
      line-height: 1.4;
    }

    #nameInput {
      background: #000;
      color: var(--primary-green);
      border: 2px solid var(--primary-green);
      padding: 12px 16px;
      font-size: clamp(1.1rem, 3vw, 1.2rem);
      font-family: 'Courier New', monospace;
      border-radius: 5px;
      margin: var(--spacing-md) auto;
      width: 90%;
      max-width: 280px;
      display: block;
      text-align: center;
    }

    #nameInput::placeholder {
      font-size: 1rem;
    }

    #loading {
      display: none;
      color: #00ffff;
      margin: 15px 0;
      animation: blink 1s infinite;
    }

    #submitMessage {
      min-height: 40px;
      margin: 15px 0 !important;
      font-weight: bold;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    /* Settings Modal */
    #settingsModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 3px solid var(--primary-green);
      border-radius: 15px;
      padding: clamp(20px, 5vw, 40px);
      z-index: 1000;
      max-width: 90%;
      width: 500px;
      max-height: 90vh;
      overflow-y: auto;
    }

    #settingsModal.show {
      display: block;
      animation: fadeIn 0.3s;
    }

    #settingsModal h2 {
      font-size: clamp(1.5rem, 4vw, 2rem);
      color: var(--accent-yellow);
      text-shadow: 0 0 10px var(--accent-yellow);
      margin-bottom: 20px;
      text-align: center;
    }

    .setting-group {
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(0,255,0,0.3);
    }

    .setting-group:last-child {
      border-bottom: none;
    }

    .setting-label {
      display: block;
      font-size: 1.1rem;
      color: var(--secondary-cyan);
      margin-bottom: 10px;
      font-weight: bold;
    }

    .speed-options {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .speed-option {
      background: rgba(0,255,0,0.1);
      border: 2px solid var(--primary-green);
      color: var(--primary-green);
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      transition: all 0.3s;
      min-width: 80px;
      text-align: center;
    }

    .speed-option:hover {
      background: rgba(0,255,0,0.2);
      transform: scale(1.05);
    }

    .speed-option.active {
      background: var(--primary-green);
      color: var(--bg-dark);
      box-shadow: 0 0 20px rgba(0,255,0,0.8);
    }

    .setting-description {
      color: #999;
      font-size: 0.9rem;
      margin-top: 8px;
      line-height: 1.4;
    }

    #settingsModal .btn {
      width: 100%;
      max-width: 200px;
      margin: 20px auto 0;
      display: block;
    }

    /* Leaderboard Modal (same styling as settings) */
    #leaderboardModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 3px solid var(--accent-yellow);
      border-radius: 15px;
      padding: clamp(20px, 5vw, 40px);
      z-index: 1000;
      max-width: 90%;
      width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    #leaderboardModal.show {
      display: block;
      animation: fadeIn 0.3s;
    }

    #leaderboardModal h2 {
      font-size: clamp(1.5rem, 4vw, 2rem);
      color: var(--accent-yellow);
      text-shadow: 0 0 10px var(--accent-yellow);
      margin-bottom: 20px;
      text-align: center;
    }

    #leaderboardModal ol {
      list-style: none;
      padding: 0;
      margin-bottom: 20px;
    }

    #leaderboardModal li {
      padding: 12px;
      margin-bottom: 8px;
      background: rgba(0,255,0,0.1);
      border: 1px solid #00ff00;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      transition: all 0.3s;
    }

    #leaderboardModal li:hover {
      background: rgba(0,255,0,0.2);
      transform: translateX(5px);
    }

    #leaderboardModal li:nth-child(1) { border-color: #ffd700; color: #ffd700; }
    #leaderboardModal li:nth-child(2) { border-color: #c0c0c0; color: #c0c0c0; }
    #leaderboardModal li:nth-child(3) { border-color: #cd7f32; color: #cd7f32; }

    #leaderboardModal .btn {
      width: 100%;
      max-width: 200px;
      margin: 10px auto 0;
      display: block;
    }

    /* Desktop: Keep side leaderboard visible */
    @media (min-width: 768px) {
      #leaderboard {
        display: block !important;
      }
    }

    /* Additional Mobile Optimizations */
    @media (max-width: 767px) {
      body {
        padding: 5px;
      }

      #gameArea {
        gap: 15px;
      }

      #leaderboard {
        order: 2; /* Show leaderboard below game on mobile */
      }

      #gameOverScreen {
        padding: 25px 15px;
        width: 95%;
      }

      #gameOverScreen h2 {
        margin-bottom: 15px;
      }

      #gameOverScreen p {
        margin: 10px 0;
      }
    }

    /* Landscape mobile */
    @media (max-width: 767px) and (orientation: landscape) {
      #container {
        grid-template-columns: 1fr 300px;
      }

      #canvas {
        aspect-ratio: 16 / 9;
      }
    }

    /* Scrollbar styling */
    #leaderboard::-webkit-scrollbar {
      width: 8px;
    }

    #leaderboard::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.5);
      border-radius: 10px;
    }

    #leaderboard::-webkit-scrollbar-thumb {
      background: #00ff00;
      border-radius: 10px;
    }

    /* ========================================
       IN-APP BROWSER MODE (Instagram/Facebook)
       Simplified layout with minimal padding and hidden UI
       ======================================== */

    body.inapp-mode {
      padding: 0 !important;
      margin: 0 !important;
      overflow-x: hidden !important;
    }

    body.inapp-mode #container {
      padding: 0 !important;
      margin: 0 !important;
      gap: 5px !important;
      max-width: 100% !important;
    }

    body.inapp-mode #gameArea {
      gap: 5px !important;
    }

    /* Hide non-essential UI in in-app browsers, but keep game controls! */
    body.inapp-mode h1,
    body.inapp-mode #leaderboard,
    body.inapp-mode #controls {
      display: none !important;
    }

    /* Keep game controls but make them more compact in in-app browsers */
    body.inapp-mode #gameControls {
      padding: 8px !important;
      gap: 6px !important;
      grid-template-columns: repeat(4, 1fr) !important;
    }

    body.inapp-mode #gameControls .btn {
      font-size: 0.75rem !important;
      padding: 8px 6px !important;
    }

    /* On mobile (not just in-app), also hide side leaderboard */
    @media (max-width: 767px) {
      #leaderboard {
        display: none !important;
      }
    }

    /* Canvas adjustments for in-app browsers */
    body.inapp-mode #canvas {
      width: 100% !important;
      max-width: 100vw !important;
      border: 0 !important;
      border-radius: 0 !important;
      box-shadow: none !important;
      margin: 0 !important;
    }

    /* Compact stats UI for in-app browsers */
    body.inapp-mode #ui {
      border-radius: 0 !important;
      border-width: 0 0 1px 0 !important;
      padding: 8px 5px !important;
      margin: 0 !important;
      font-size: clamp(0.8rem, 2vw, 0.95rem) !important;
    }

    body.inapp-mode #topBar {
      margin-bottom: 0 !important;
      gap: 0 !important;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="gameArea">
      <h1>üéÆ BB-BOUNCE</h1>

      <!-- Top Bar: Stats + Controls -->
      <div id="topBar">
        <div id="ui">
          <div>Score: <span id="score">0</span></div>
          <div>Lives: <span id="lives">3</span></div>
          <div>Level: <span id="level">1</span></div>
          <div>Speed: <span id="speedDisplay">1x</span></div>
        </div>
        <div id="gameControls">
          <button class="btn" id="restartBtn">New Game</button>
          <button class="btn" id="pauseBtn">Pause</button>
          <button class="btn" id="leaderboardBtn">üèÜ Scores</button>
          <button class="btn" id="settingsBtn">‚öôÔ∏è</button>
        </div>
      </div>

      <canvas id="canvas" width="800" height="600"></canvas>

      <div id="controls">
        <p><strong>Controls:</strong> Arrow Keys / Mouse / Touch to move paddle</p>
        <p>Spacebar or Tap to launch ball | ESC to pause</p>
      </div>
    </div>

    <div id="leaderboard">
      <h2>üèÜ TOP 10 GLOBAL</h2>
      <ol id="scoresList">
        <li style="text-align:center; color:#666;">Loading...</li>
      </ol>
      <div style="text-align:center; margin-top:20px;">
        <button class="btn" id="refreshBtn">Refresh</button>
      </div>
    </div>
  </div>

  <!-- Game Over Modal -->
  <div id="gameOverScreen">
    <h2>GAME OVER</h2>
    <p>Final Score: <span id="finalScore" style="color:#00ffff;">0</span></p>
    <p>Level Reached: <span id="finalLevel" style="color:#ffff00;">1</span></p>
    <p id="rankMessage" style="color:#00ff00; margin:20px 0;"></p>

    <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" value="">
    <br>
    <button class="btn" id="submitBtn">Submit Score</button>
    <button class="btn" id="playAgainBtn">Play Again</button>
    <p id="loading">Submitting...</p>
    <p id="submitMessage" style="margin-top:10px;"></p>
  </div>

  <!-- Leaderboard Modal (for mobile) -->
  <div id="leaderboardModal">
    <h2>üèÜ TOP 10 GLOBAL</h2>
    <ol id="scoresListModal">
      <li style="text-align:center; color:#666;">Loading...</li>
    </ol>
    <button class="btn" id="refreshModalBtn">Refresh</button>
    <button class="btn" id="closeLeaderboardBtn">Close</button>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal">
    <h2>‚öôÔ∏è GAME SETTINGS</h2>

    <div class="setting-group">
      <label class="setting-label">Ball Speed Multiplier</label>
      <div class="speed-options">
        <button class="speed-option active" data-speed="1">1x Normal</button>
        <button class="speed-option" data-speed="2">2x Fast</button>
        <button class="speed-option" data-speed="3">3x Extreme</button>
      </div>
      <p class="setting-description">
        Controls how fast the ball moves. Higher speeds = harder gameplay but more challenge!
      </p>
    </div>

    <div class="setting-group">
      <label class="setting-label">Haptic Feedback (Vibration)</label>
      <div class="speed-options">
        <button class="haptic-option" data-haptic="off">Off</button>
        <button class="haptic-option" data-haptic="minimal">Minimal</button>
        <button class="haptic-option active" data-haptic="full">Full</button>
      </div>
      <p class="setting-description">
        Controls vibration feedback on mobile devices. Full = all events, Minimal = major events only, Off = no vibration.
      </p>
    </div>

    <button class="btn" id="closeSettingsBtn">Close</button>
  </div>

  <script>
    // ============================================
    // BB-BOUNCE - BRICK BREAKER GAME
    // Vanilla JavaScript + Canvas API
    // Author: Christopher Junker
    // ============================================

    // ============================================
    // IN-APP BROWSER DETECTION
    // ============================================

    /**
     * Detect if running in Instagram or Facebook in-app browser
     * @returns {boolean} True if in-app browser detected
     */
    function isInAppBrowser() {
      const ua = navigator.userAgent || navigator.vendor || window.opera;
      // Check for Instagram
      if (ua.indexOf('Instagram') > -1) return true;
      // Check for Facebook
      if (ua.indexOf('FBAN') > -1 || ua.indexOf('FBAV') > -1) return true;
      // Check URL parameter override
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('inapp') === 'true') return true;
      return false;
    }

    // Apply in-app browser mode class
    const inAppMode = isInAppBrowser();
    if (inAppMode) {
      document.body.classList.add('inapp-mode');
      console.log('üì± In-app browser detected - compact layout with controls preserved');
    } else {
      console.log('üåê Standard browser mode');
    }

    // API Configuration
    const API_URL = window.location.origin + '/api';
    const SCORE_SECRET = 'b3481ca0fc3799ed1e124e795eb34420d58281677a4ffa60dfd306b4c7f3fefd';

    // ============================================
    // HAPTIC FEEDBACK SYSTEM
    // ============================================

    /**
     * Haptic feedback configuration
     * Users can toggle: 'off', 'minimal', 'full'
     */
    let hapticsEnabled = localStorage.getItem('bbBounceHaptics') || 'full';

    /**
     * Trigger haptic feedback vibration
     * @param {string} type - Type of haptic feedback (light, medium, heavy, loss)
     */
    function hapticFeedback(type = 'light') {
      // Check if haptics are disabled
      if (hapticsEnabled === 'off') return;

      // Check browser support with robust feature detection
      if (!navigator || typeof navigator.vibrate !== 'function') {
        // Silently fail on unsupported browsers (Instagram, old browsers, desktop)
        return;
      }

      // Define vibration patterns
      const patterns = {
        light: 10,                    // Ball hit paddle or wall
        medium: 30,                   // Brick destroyed
        heavy: [50, 30, 50],         // Level complete
        loss: [100, 50, 100, 50, 100], // Lose life
        gameOver: [200, 100, 200]    // Game over
      };

      // Minimal mode: only heavy feedback (level complete, life lost)
      if (hapticsEnabled === 'minimal' && !['heavy', 'loss', 'gameOver'].includes(type)) {
        return;
      }

      // Trigger vibration with try-catch for safety
      try {
        const pattern = patterns[type] || patterns.light;
        navigator.vibrate(pattern);
      } catch (error) {
        // Silently fail if vibration throws an error
        console.warn('Haptic feedback not supported:', error);
      }
    }

    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Responsive canvas sizing
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      // Determine aspect ratio based on viewport
      const isMobile = window.innerWidth < 768;
      const isLandscape = window.innerWidth > window.innerHeight;

      let targetWidth, targetHeight;

      if (isMobile && !isLandscape) {
        // Mobile portrait: 3:4 ratio (taller canvas)
        targetWidth = 600;
        targetHeight = 800;
      } else if (isMobile && isLandscape) {
        // Mobile landscape: 16:9 ratio
        targetWidth = 800;
        targetHeight = 450;
      } else {
        // Desktop: 4:3 ratio (original)
        targetWidth = 800;
        targetHeight = 600;
      }

      canvas.width = targetWidth;
      canvas.height = targetHeight;
    }

    // Game constants (will scale with canvas size)
    const PADDLE_WIDTH = 100;
    const PADDLE_HEIGHT = 15;
    const PADDLE_SPEED = 8;
    const BALL_RADIUS = 10;
    const BALL_SPEED_INITIAL = 4;
    const BRICK_ROWS = 5;
    const BRICK_COLS = 10;
    const BRICK_WIDTH = 75;
    const BRICK_HEIGHT = 20;
    const BRICK_PADDING = 5;
    const BRICK_OFFSET_TOP = 60;
    const BRICK_OFFSET_LEFT = 30;

    // Game state
    let score = 0;
    let lives = 3;
    let level = 1;
    let highScore = parseInt(localStorage.getItem('bbBounceHigh') || '0');
    let speedMultiplier = parseFloat(localStorage.getItem('bbBounceSpeedMultiplier') || '1');
    let gameRunning = false;
    let gamePaused = false;
    let ballLaunched = false;

    // Paddle
    let paddleX = (canvas.width - PADDLE_WIDTH) / 2;
    let rightPressed = false;
    let leftPressed = false;
    let mouseX = paddleX;
    let touchX = paddleX;

    // Ball
    let ballX = canvas.width / 2;
    let ballY = canvas.height - 30;
    let ballSpeedX = 0;
    let ballSpeedY = 0;
    let ballSpeed = BALL_SPEED_INITIAL;

    // Bricks
    let bricks = [];

    // ============================================
    // DIFFICULTY SCALING SYSTEM
    // ============================================

    /**
     * Calculate number of brick rows based on current level
     * Levels 1-5: Add 1 row per level (5, 6, 7, 8, 9 rows)
     * Level 6+: Cap at 10 rows maximum
     * @param {number} currentLevel - The current game level
     * @returns {number} Number of brick rows (5-10)
     */
    function calculateBrickRows(currentLevel) {
      const baseRows = 5;
      const maxRows = 10;
      return Math.min(baseRows + currentLevel - 1, maxRows);
    }

    /**
     * Calculate block hit requirements based on level
     * Levels 1-6: All 1-hit blocks
     * Levels 7+: Progressive introduction of multi-hit blocks
     * @param {number} currentLevel - The current game level
     * @param {number} rowIndex - Row index (0-based)
     * @returns {number} Required hits to destroy (1-4)
     */
    function calculateBlockHitRequirement(currentLevel, rowIndex) {
      // Phase 1: Levels 1-6 - Standard 1-hit blocks only
      if (currentLevel <= 6) {
        return 1;
      }

      // Phase 2: Levels 7-9 - Introduce 2-hit blocks (50%)
      if (currentLevel >= 7 && currentLevel <= 9) {
        // Top 50% of rows become 2-hit blocks
        const totalRows = calculateBrickRows(currentLevel);
        const twoHitThreshold = Math.floor(totalRows / 2);
        return rowIndex < twoHitThreshold ? 2 : 1;
      }

      // Phase 3: Levels 10-12 - Add 3-hit blocks
      if (currentLevel >= 10 && currentLevel <= 12) {
        const totalRows = calculateBrickRows(currentLevel);
        const threeHitThreshold = Math.floor(totalRows * 0.25); // Top 25%
        const twoHitThreshold = Math.floor(totalRows * 0.65); // Next 40%

        if (rowIndex < threeHitThreshold) return 3;
        if (rowIndex < twoHitThreshold) return 2;
        return 1;
      }

      // Phase 4: Levels 13+ - Progressive hardening
      if (currentLevel >= 13) {
        const totalRows = calculateBrickRows(currentLevel);
        const threeHitThreshold = Math.floor(totalRows * 0.5); // Top 50%
        const twoHitThreshold = Math.floor(totalRows * 0.8); // Next 30%

        if (rowIndex < threeHitThreshold) return 3;
        if (rowIndex < twoHitThreshold) return 2;
        return 1;
      }

      return 1;
    }

    /**
     * Get color for brick based on hit requirement and current state
     * @param {number} maxHits - Maximum hits required
     * @param {number} currentHits - Current hit count
     * @param {number} rowIndex - Row index for base color
     * @returns {string} Hex color code
     */
    function getBrickColor(maxHits, currentHits, rowIndex) {
      const baseColors = ['#ff0000', '#ff7700', '#ffff00', '#00ff00', '#0077ff'];
      const baseColor = baseColors[rowIndex % baseColors.length];

      // For 1-hit blocks, use standard bright colors
      if (maxHits === 1) {
        return baseColor;
      }

      // For multi-hit blocks, darken based on remaining hits
      const hitRatio = currentHits / maxHits;

      // Parse hex color
      const r = parseInt(baseColor.substr(1, 2), 16);
      const g = parseInt(baseColor.substr(3, 2), 16);
      const b = parseInt(baseColor.substr(5, 2), 16);

      // Darken color based on damage (more hits = darker)
      const darkenFactor = 0.4 + (hitRatio * 0.6); // 40% to 100% brightness
      const newR = Math.floor(r * darkenFactor);
      const newG = Math.floor(g * darkenFactor);
      const newB = Math.floor(b * darkenFactor);

      return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
    }

    /**
     * Calculate score for destroying a block
     * @param {number} maxHits - Maximum hits required for this block
     * @returns {number} Points awarded
     */
    function calculateBlockScore(maxHits) {
      const baseScore = 10;
      switch(maxHits) {
        case 1: return baseScore;        // 10 points
        case 2: return baseScore * 2.5;  // 25 points
        case 3: return baseScore * 5;    // 50 points
        case 4: return baseScore * 10;   // 100 points
        default: return baseScore;
      }
    }

    // ============================================
    // GAME INITIALIZATION
    // ============================================

    function init() {
      resizeCanvas(); // Set canvas dimensions based on viewport
      score = 0;
      lives = 3;
      level = 1;
      gameRunning = true;

      // Start paused on mobile to prevent accidental starts
      const isMobile = window.innerWidth < 768;
      gamePaused = isMobile;
      if (gamePaused) {
        document.getElementById('pauseBtn').textContent = 'Start';
      }

      ballLaunched = false;
      ballSpeed = BALL_SPEED_INITIAL;
      updateUI();
      initBricks();
      resetBall();
      gameLoop();
      loadLeaderboard();
    }

    function initBricks() {
      bricks = [];

      // Calculate dynamic number of rows based on current level
      const currentRows = calculateBrickRows(level);

      // Calculate responsive brick dimensions
      const margin = 20; // Side margins
      const availableWidth = canvas.width - (margin * 2);
      const totalPadding = BRICK_PADDING * (BRICK_COLS - 1);
      const brickWidth = (availableWidth - totalPadding) / BRICK_COLS;

      // Use consistent brick height (scaled proportionally for responsive width)
      // This keeps bricks at fixed height across all levels, letting rows naturally fill more space
      const brickHeight = BRICK_HEIGHT * (brickWidth / BRICK_WIDTH);

      for (let c = 0; c < BRICK_COLS; c++) {
        bricks[c] = [];
        for (let r = 0; r < currentRows; r++) {
          // Calculate hit requirements for this block
          const maxHits = calculateBlockHitRequirement(level, r);

          bricks[c][r] = {
            x: margin + c * (brickWidth + BRICK_PADDING),
            y: BRICK_OFFSET_TOP + r * (brickHeight + BRICK_PADDING),
            width: brickWidth,
            height: brickHeight,
            status: 1,                    // 0 = destroyed, 1 = active
            maxHits: maxHits,             // NEW: Total hits required to destroy
            currentHits: 0,               // NEW: Number of times hit
            color: getBrickColor(maxHits, 0, r)
          };
        }
      }
    }

    function resetBall() {
      ballX = paddleX + PADDLE_WIDTH / 2;
      ballY = canvas.height - 50;
      ballSpeedX = 0;
      ballSpeedY = 0;
      ballLaunched = false;
    }

    function launchBall() {
      if (!ballLaunched && gameRunning && !gamePaused) {
        const angle = (Math.random() - 0.5) * Math.PI / 3; // -30¬∞ to +30¬∞
        const effectiveSpeed = ballSpeed * speedMultiplier;
        ballSpeedX = effectiveSpeed * Math.sin(angle);
        ballSpeedY = -effectiveSpeed * Math.cos(angle);
        ballLaunched = true;
      }
    }

    // ============================================
    // GAME LOOP
    // ============================================

    function gameLoop() {
      if (!gameRunning) return;

      if (!gamePaused) {
        update();
      }

      // Always draw, even when paused (shows scene with overlay)
      draw();

      requestAnimationFrame(gameLoop);
    }

    function update() {
      // Move paddle
      if (rightPressed && paddleX < canvas.width - PADDLE_WIDTH) {
        paddleX += PADDLE_SPEED;
      }
      if (leftPressed && paddleX > 0) {
        paddleX -= PADDLE_SPEED;
      }

      // Mouse/touch control
      if (mouseX !== null) {
        paddleX = Math.max(0, Math.min(canvas.width - PADDLE_WIDTH, mouseX - PADDLE_WIDTH / 2));
      }

      // Ball follows paddle if not launched
      if (!ballLaunched) {
        ballX = paddleX + PADDLE_WIDTH / 2;
        ballY = canvas.height - 50;
        return;
      }

      // Move ball
      ballX += ballSpeedX;
      ballY += ballSpeedY;

      // Wall collision (left/right)
      if (ballX + ballSpeedX > canvas.width - BALL_RADIUS || ballX + ballSpeedX < BALL_RADIUS) {
        ballSpeedX = -ballSpeedX;
        hapticFeedback('light'); // Wall bounce feedback
      }

      // Wall collision (top)
      if (ballY + ballSpeedY < BALL_RADIUS) {
        ballSpeedY = -ballSpeedY;
        hapticFeedback('light'); // Top wall bounce feedback
      }

      // Paddle collision
      if (ballY + BALL_RADIUS > canvas.height - PADDLE_HEIGHT - 20 && ballY < canvas.height - 20) {
        if (ballX > paddleX && ballX < paddleX + PADDLE_WIDTH) {
          // Add spin based on where ball hits paddle
          const hitPos = (ballX - paddleX) / PADDLE_WIDTH; // 0 to 1
          const angle = (hitPos - 0.5) * Math.PI / 2; // -45¬∞ to +45¬∞
          const effectiveSpeed = ballSpeed * speedMultiplier;
          ballSpeedX = effectiveSpeed * Math.sin(angle);
          ballSpeedY = -Math.abs(effectiveSpeed * Math.cos(angle)); // Always up
          hapticFeedback('light'); // Paddle hit feedback
        }
      }

      // Bottom collision (lose life)
      if (ballY + ballSpeedY > canvas.height - BALL_RADIUS) {
        loseLife();
      }

      // Brick collision
      checkBrickCollision();
    }

    function checkBrickCollision() {
      for (let c = 0; c < BRICK_COLS; c++) {
        // Use actual array length for dynamic rows
        if (!bricks[c]) continue;

        for (let r = 0; r < bricks[c].length; r++) {
          const brick = bricks[c][r];
          if (!brick || brick.status === 0) continue;

          // Check collision
          if (
            ballX > brick.x &&
            ballX < brick.x + brick.width &&
            ballY > brick.y &&
            ballY < brick.y + brick.height
          ) {
            // Bounce ball
            ballSpeedY = -ballSpeedY;

            // Increment hit count
            brick.currentHits++;

            // Check if brick should be destroyed
            if (brick.currentHits >= brick.maxHits) {
              // Destroy brick
              brick.status = 0;

              // Award full score based on block difficulty
              score += calculateBlockScore(brick.maxHits);

              // Haptic feedback based on brick difficulty
              if (brick.maxHits >= 3) {
                hapticFeedback('heavy'); // Multi-hit brick destroyed
              } else {
                hapticFeedback('medium'); // Standard brick destroyed
              }
            } else {
              // Partial hit - award partial points and update color
              score += 5; // Partial credit for hitting but not destroying

              // Update brick color to show damage
              brick.color = getBrickColor(brick.maxHits, brick.currentHits, r);

              hapticFeedback('light'); // Brick damaged but not destroyed
            }

            updateUI();

            // Check level complete
            if (checkAllBricksCleared()) {
              levelComplete();
            }

            // Only process one brick collision per frame
            return;
          }
        }
      }
    }

    function checkAllBricksCleared() {
      return bricks.every(col => col.every(brick => brick.status === 0));
    }

    function levelComplete() {
      score += level * 100; // Bonus
      level++;
      ballSpeed += 0.5; // Increase difficulty
      initBricks();
      resetBall();
      updateUI();
      showMessage(`Level ${level}!`, '#ffff00');
      hapticFeedback('heavy'); // Level complete celebration!
    }

    function loseLife() {
      lives--;
      updateUI();
      hapticFeedback('loss'); // Lose life feedback
      if (lives <= 0) {
        gameOver();
      } else {
        resetBall();
        showMessage(`${lives} lives left`, '#ff7700');
      }
    }

    function gameOver() {
      gameRunning = false;
      hapticFeedback('gameOver'); // Game over feedback
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('bbBounceHigh', highScore);
      }
      showGameOverScreen();
    }

    // ============================================
    // RENDERING
    // ============================================

    function draw() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw bricks
      bricks.forEach(col => {
        col.forEach(brick => {
          if (brick.status === 1) {
            // Draw brick fill
            ctx.fillStyle = brick.color;
            ctx.fillRect(brick.x, brick.y, brick.width, brick.height);

            // Draw border (enhanced for multi-hit blocks)
            if (brick.maxHits > 1) {
              // Multi-hit blocks have thicker, glowing borders
              ctx.strokeStyle = brick.currentHits > 0 ? '#ff00ff' : '#00ffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

              // Add inner border for damaged blocks
              if (brick.currentHits > 0) {
                ctx.strokeStyle = 'rgba(255,0,255,0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(brick.x + 2, brick.y + 2, brick.width - 4, brick.height - 4);
              }
            } else {
              // Standard blocks have thin white borders
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 1;
              ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
            }
          }
        });
      });

      // Draw paddle
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(paddleX, canvas.height - 30, PADDLE_WIDTH, PADDLE_HEIGHT);

      // Draw ball
      ctx.beginPath();
      ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = '#00ffff';
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.closePath();

      // Draw pause overlay with button
      if (gamePaused) {
        // Semi-transparent overlay (lighter so game is visible)
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const isMobile = window.innerWidth < 768;

        // Draw centered START button
        const buttonWidth = Math.min(canvas.width * 0.6, 300);
        const buttonHeight = 80;
        const buttonX = (canvas.width - buttonWidth) / 2;
        const buttonY = (canvas.height - buttonHeight) / 2;

        // Button shadow
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(buttonX + 4, buttonY + 4, buttonWidth, buttonHeight);

        // Button background
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

        // Button border
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 4;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

        // Button text
        const fontSize = Math.min(buttonWidth / 6, 36);
        ctx.fillStyle = '#000';
        ctx.font = `bold ${fontSize}px Courier New`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const message = isMobile ? 'TAP TO START' : 'CLICK TO START';
        ctx.fillText(message, canvas.width / 2, canvas.height / 2);

        // Instruction text above button
        ctx.font = `${fontSize * 0.5}px Courier New`;
        ctx.fillStyle = '#ffff00';
        ctx.fillText('Game Ready', canvas.width / 2, buttonY - 30);
      }
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('lives').textContent = lives;
      document.getElementById('level').textContent = level;
      document.getElementById('speedDisplay').textContent = speedMultiplier + 'x';
    }

    function showMessage(text, color) {
      // Simple flash message on canvas (could be improved)
      console.log(text);
    }

    // ============================================
    // INPUT HANDLING
    // ============================================

    // Keyboard
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
      if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
      if (e.key === ' ' || e.key === 'Spacebar') launchBall();
      if (e.key === 'Escape') togglePause();
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
      if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
    });

    // Mouse
    document.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      // Scale mouse position to canvas coordinates
      const scaleX = canvas.width / rect.width;
      mouseX = (e.clientX - rect.left) * scaleX;
    });

    canvas.addEventListener('click', (e) => {
      // If paused, clicking unpauses (acts like Start button)
      if (gamePaused) {
        togglePause();
      } else {
        // If not paused, launch ball
        launchBall();
      }
    });

    // Touch
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      // Scale touch position to canvas coordinates
      const scaleX = canvas.width / rect.width;
      mouseX = (touch.clientX - rect.left) * scaleX;
    }, { passive: false });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      // Snap paddle to touch position
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      // Scale touch position to canvas coordinates
      const scaleX = canvas.width / rect.width;
      mouseX = (touch.clientX - rect.left) * scaleX;

      // If paused, unpause (acts like Start button)
      if (gamePaused) {
        togglePause();
      } else {
        // If not paused, launch ball
        launchBall();
      }
    }, { passive: false });

    // Buttons
    document.getElementById('restartBtn').addEventListener('click', init);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('refreshBtn').addEventListener('click', loadLeaderboard);
    document.getElementById('leaderboardBtn').addEventListener('click', openLeaderboard);
    document.getElementById('settingsBtn').addEventListener('click', openSettings);
    document.getElementById('closeSettingsBtn').addEventListener('click', closeSettings);
    document.getElementById('closeLeaderboardBtn').addEventListener('click', closeLeaderboard);
    document.getElementById('refreshModalBtn').addEventListener('click', () => {
      loadLeaderboard();
    });

    function togglePause() {
      if (!gameRunning) return;
      gamePaused = !gamePaused;

      const pauseBtn = document.getElementById('pauseBtn');
      if (gamePaused) {
        pauseBtn.textContent = 'Resume';
      } else {
        pauseBtn.textContent = 'Pause';
      }
    }

    function openSettings() {
      // Pause game if running
      if (gameRunning && !gamePaused) {
        togglePause();
      }

      // Update active button based on current speed
      document.querySelectorAll('.speed-option').forEach(btn => {
        const btnSpeed = parseFloat(btn.dataset.speed);
        if (btnSpeed === speedMultiplier) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });

      // Update active button based on current haptic setting (if available)
      const hapticSection = document.querySelector('.setting-group:has(.haptic-option)');
      if (navigator && typeof navigator.vibrate === 'function') {
        // Haptic API supported - show settings
        if (hapticSection) hapticSection.style.display = 'block';

        document.querySelectorAll('.haptic-option').forEach(btn => {
          const btnHaptic = btn.dataset.haptic;
          if (btnHaptic === hapticsEnabled) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      } else {
        // Haptic API not supported - hide settings section
        if (hapticSection) {
          hapticSection.style.display = 'none';
          console.log('‚ÑπÔ∏è Haptic settings hidden (not supported on this device)');
        }
      }

      document.getElementById('settingsModal').classList.add('show');
    }

    function closeSettings() {
      document.getElementById('settingsModal').classList.remove('show');
    }

    function openLeaderboard() {
      // Pause game if running
      if (gameRunning && !gamePaused) {
        togglePause();
      }

      // Refresh leaderboard data
      loadLeaderboard();

      document.getElementById('leaderboardModal').classList.add('show');
    }

    function closeLeaderboard() {
      document.getElementById('leaderboardModal').classList.remove('show');
    }

    // Speed option handlers
    document.querySelectorAll('.speed-option').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const newSpeed = parseFloat(e.target.dataset.speed);
        setSpeedMultiplier(newSpeed);

        // Update active state
        document.querySelectorAll('.speed-option').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
      });
    });

    // Haptic option handlers
    document.querySelectorAll('.haptic-option').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const newHaptic = e.target.dataset.haptic;
        setHapticMode(newHaptic);

        // Update active state
        document.querySelectorAll('.haptic-option').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');

        // Test haptic feedback immediately
        hapticFeedback('medium');
      });
    });

    function setSpeedMultiplier(multiplier) {
      speedMultiplier = multiplier;
      localStorage.setItem('bbBounceSpeedMultiplier', multiplier);
      updateUI();

      // If ball is launched, update its speed immediately
      if (ballLaunched) {
        const currentSpeed = Math.sqrt(ballSpeedX ** 2 + ballSpeedY ** 2);
        const targetSpeed = ballSpeed * speedMultiplier;
        const ratio = targetSpeed / currentSpeed;
        ballSpeedX *= ratio;
        ballSpeedY *= ratio;
      }
    }

    function setHapticMode(mode) {
      hapticsEnabled = mode;
      localStorage.setItem('bbBounceHaptics', mode);
      console.log('Haptic feedback mode:', mode);
    }

    // ============================================
    // LEADERBOARD API
    // ============================================

    async function loadLeaderboard() {
      try {
        const res = await fetch(`${API_URL}/scores`);
        const data = await res.json();
        displayLeaderboard(data.scores || []);
      } catch (error) {
        console.error('Failed to load leaderboard:', error);
        document.getElementById('scoresList').innerHTML = '<li style="color:#ff0000;">Offline</li>';
      }
    }

    function displayLeaderboard(scores) {
      const markup = scores.length === 0
        ? '<li style="text-align:center;color:#666;">No scores yet!</li>'
        : scores.map((s, i) => {
            const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;
            return `
              <li>
                <span class="rank">${medal}</span>
                <span class="player-name">${s.name}</span>
                <span class="player-score">${s.score.toLocaleString()}</span>
              </li>
            `;
          }).join('');

      // Update both sidebar and modal
      const sidebarList = document.getElementById('scoresList');
      const modalList = document.getElementById('scoresListModal');

      if (sidebarList) sidebarList.innerHTML = markup;
      if (modalList) modalList.innerHTML = markup;
    }

    async function submitScore() {
      const name = document.getElementById('nameInput').value.trim() || 'Anonymous';
      const loading = document.getElementById('loading');
      const submitBtn = document.getElementById('submitBtn');
      const message = document.getElementById('submitMessage');

      loading.style.display = 'block';
      submitBtn.disabled = true;
      message.textContent = '';

      try {
        const res = await fetch(`${API_URL}/submit`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name,
            score,
            level,
            secret: SCORE_SECRET
          })
        });

        const data = await res.json();

        if (res.ok) {
          message.style.color = '#00ff00';
          message.textContent = `üéâ Score submitted! You're rank #${data.rank}`;
          localStorage.setItem('bbBounceName', name);
          setTimeout(loadLeaderboard, 1000);
        } else {
          message.style.color = '#ff0000';
          message.textContent = data.error || 'Submission failed';
        }
      } catch (error) {
        message.style.color = '#ff7700';
        message.textContent = 'Offline. Score saved locally.';
        // Queue for later (could implement retry logic)
      } finally {
        loading.style.display = 'none';
        submitBtn.disabled = false;
      }
    }

    function showGameOverScreen() {
      document.getElementById('finalScore').textContent = score.toLocaleString();
      document.getElementById('finalLevel').textContent = level;
      document.getElementById('nameInput').value = localStorage.getItem('bbBounceName') || '';

      const msg = score >= 1000 ? `Amazing! ${score} points!` : score >= 500 ? 'Great job!' : 'Better luck next time!';
      document.getElementById('rankMessage').textContent = msg;

      document.getElementById('gameOverScreen').classList.add('show');
    }

    document.getElementById('submitBtn').addEventListener('click', submitScore);
    document.getElementById('playAgainBtn').addEventListener('click', () => {
      document.getElementById('gameOverScreen').classList.remove('show');
      init();
    });

    document.getElementById('nameInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') submitScore();
    });

    // ============================================
    // PAGE VISIBILITY API - AUTO-PAUSE
    // ============================================

    /**
     * Auto-pause game when user switches tabs or minimizes browser
     * Saves battery and prevents unfair gameplay
     * WITH FALLBACK: Only runs if Page Visibility API is supported
     */
    if (typeof document.hidden !== 'undefined') {
      document.addEventListener('visibilitychange', () => {
        try {
          if (document.hidden) {
            // Page is hidden - auto-pause if game is running
            if (gameRunning && !gamePaused) {
              togglePause();
              console.log('‚è∏Ô∏è Game auto-paused (tab hidden)');
            }
          } else {
            // Page is visible again
            // Don't auto-resume - let user manually resume for fairness
            console.log('üëÄ Game ready to resume (tab visible)');
          }
        } catch (error) {
          console.warn('Page Visibility API error:', error);
        }
      });
      console.log('‚úÖ Page Visibility API active');
    } else {
      console.log('‚ö†Ô∏è Page Visibility API not supported - auto-pause disabled');
    }

    // ============================================
    // PWA SERVICE WORKER REGISTRATION
    // ============================================

    /**
     * Register service worker for offline support and caching
     * WITH FALLBACK: Only runs if Service Worker API is supported and in secure context
     */
    if ('serviceWorker' in navigator && (window.location.protocol === 'https:' || window.location.hostname === 'localhost')) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('‚úÖ Service Worker registered:', registration.scope);

            // Check for updates periodically (only if supported)
            if (registration.update) {
              setInterval(() => {
                registration.update().catch(err => {
                  console.warn('Service Worker update check failed:', err);
                });
              }, 60000); // Check every minute
            }
          })
          .catch((error) => {
            console.warn('‚ö†Ô∏è Service Worker registration failed (may not be supported):', error);
            console.log('üì° App will work without offline support');
          });
      });

      // Listen for service worker updates (with error handling)
      try {
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          console.log('üîÑ Service Worker updated');
        });
      } catch (error) {
        console.warn('Service Worker event listener error:', error);
      }
    } else {
      console.log('‚ö†Ô∏è Service Worker not supported or not in secure context');
      console.log('üì° App works in online-only mode (this is fine!)');
    }

    // ============================================
    // PWA INSTALL PROMPT (Optional Enhancement)
    // ============================================

    /**
     * PWA Install Prompt Handler
     * WITH FALLBACK: Only runs if browser supports beforeinstallprompt
     */
    let deferredPrompt;

    // Check if install prompt is supported (Chrome, Edge, Samsung Internet)
    if ('BeforeInstallPromptEvent' in window || true) { // Always attach, browser will ignore if not supported
      try {
        window.addEventListener('beforeinstallprompt', (e) => {
          // Prevent Chrome 67 and earlier from automatically showing the prompt
          e.preventDefault();
          // Stash the event so it can be triggered later
          deferredPrompt = e;

          console.log('üíæ PWA install available!');

          // Optional: Show custom install button in UI
          // For now, users can install via browser menu
        });

        window.addEventListener('appinstalled', () => {
          console.log('üéâ PWA installed successfully!');
          deferredPrompt = null;
        });
      } catch (error) {
        console.warn('PWA install events not supported:', error);
      }
    } else {
      console.log('üì± PWA install prompt not supported (may still be installable via browser menu)');
    }

    // ============================================
    // START GAME
    // ============================================

    init();
  </script>
</body>
</html>
